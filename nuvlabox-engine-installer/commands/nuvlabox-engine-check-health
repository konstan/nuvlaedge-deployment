#!/usr/bin/env python3

import docker
import sys
import time
import signal
import logging
from contextlib import contextmanager


timer = int(sys.argv[1])

@contextmanager
def timeout(deadline):
    # Register a function to raise a TimeoutError on the signal.
    signal.signal(signal.SIGALRM, raise_timeout)
    # Schedule the signal to be sent after ``time``.
    signal.alarm(deadline)

    try:
        yield
    except TimeoutError:
        raise Exception(f'Exceeded the timeout of {timer} sec while waiting for NuvlaEdge installation to be healthy')
    finally:
        # Unregister the signal so it won't be triggered
        # if the timeout is not reached.
        signal.signal(signal.SIGALRM, signal.SIG_IGN)


def raise_timeout(signum, frame):
    raise TimeoutError


def is_agent(container):
    return container.labels.get('com.docker.compose.service', '') == 'agent'


def get_containers(docker_client):
    filters = {'label': "nuvlabox.component=True"}
    return docker_client.containers.list(filters=filters, all=True)


def check_container_running(container):
    status = container.status
    if not status or status.lower() != 'running':
        return False, f'container "{container.name}" status not running: {status}'
    return True, ''


def check_restart_count(container):
    restart_count = container.attrs.get('RestartCount', 0)
    if restart_count != 0:
        return False, f'container "{container.name}" restart count not zero: {restart_count}'
    return True, ''


def check_health_state(container):
    state = container.attrs.get('State')
    if not state:
        return False, f'container "{container.name}" state not available'

    health = state.get('Health')
    if not health:
        return True, f'container "{container.name}" health not available (not an issue)'

    status = health.get('Status')
    if not status or status.lower() != 'healthy':
        return False, f'container "{container.name}" status not healthy: {status}'

    return True, ''


def handle_result(command_return, results, messages):
    res, msg = command_return
    results.append(res)
    if msg:
        messages.append(msg)
    logging.info(msg)


last_messages = []

try:
    docker_client = docker.from_env()

    with timeout(timer):
        while True:
            results = []
            messages = []

            try:
                containers = get_containers(docker_client)
            except docker.errors.APIError:
                continue

            for container in containers:
                local_results = []
                if is_agent(container):
                    handle_result(check_restart_count(container), local_results, messages)
                    handle_result(check_container_running(container), local_results, messages)
                handle_result(check_health_state(container), local_results, messages)
                results.append(local_results and all(local_results))

            last_messages = messages

            if all(results):
                break

            time.sleep(3)

except Exception as e:
    messages = "\n".join(last_messages)
    print(f'{e}')
    print(f'Messages: \n{messages}')
    # making sure that only the error message is printed and not the whole exception
    raise
